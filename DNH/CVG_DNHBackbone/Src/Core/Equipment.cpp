#include "Equipment.h"

//https://stackoverflow.com/a/3248017/2680066
#include <boost/uuid/uuid.hpp>            // uuid class
#include <boost/uuid/uuid_generators.hpp> // generators
#include <boost/uuid/uuid_io.hpp>         // streaming operators etc.
#include <boost/lexical_cast.hpp>
#include "ResponseUtils.h"

/// <summary>
/// GUID/UUID generator.
/// 
/// Used for GUID generation in Equipment. It's given its own class
/// in case the implementation is changed, in which case Generate()
/// should still be called but have a different implementation. This
/// allows extra utility functions to be added in the GUIGenerator
/// struct so it would be tied with the same scope as Generate().
/// </summary>
struct GUIDGenerator
{
	static std::string Generate()
	{
		boost::uuids::uuid uuid = boost::uuids::random_generator()();
		return boost::lexical_cast<std::string>(uuid);
	}
};


namespace CVG
{
	Equipment::Equipment(
		const std::string& name,
		const std::string& manufacturer,
		const std::string& purpose,
		const std::string & hostname,
		EQType type,
		std::vector<ParamSPtr> params,
		json clientData)
	{
		// The GUID isn't specified, it's autogenerated on 
		// construction to ensure each Equipment instance
		// has a unique one.
		this->guid = GUIDGenerator::Generate();

		this->name = name;
		this->manufacturer = manufacturer;
		this->purpose = purpose;
		this->hostname = hostname;
		this->equipmentType = type;
		this->params = params;
		this->clientData = clientData;
	}

	bool Equipment::Deactivate()
	{
		if (this->active == false)
			return false;

		this->active = false;
		return true;
	}

	bool Equipment::IsSubscribed(const std::string& channel)
	{
		const std::lock_guard<std::mutex> lock(this->topicsMutex);
		return this->topics.find(channel) != this->topics.end();
	}

	bool Equipment::Subscribe(const std::vector<std::string>& channels)
	{
		bool ret = false;
		const std::lock_guard<std::mutex> lock(this->topicsMutex);
		for (const std::string& chan : topics)
		{
			if (this->topics.find(chan) != this->topics.end())
				continue;

			this->topics.insert(chan);
			ret = true;
		}
		return ret;
	}

	bool Equipment::Unsubscribe(const std::vector<std::string>& channels)
	{
		bool ret = false;
		const std::lock_guard<std::mutex> lock(this->topicsMutex);
		for (const std::string& chan : channels)
		{
			if (this->topics.find(chan) == this->topics.end())
				continue;

			this->topics.erase(chan);
			ret = true;
		}
		return ret;
	}

	bool Equipment::Subscribe(const std::string& channel)
	{
		std::vector<std::string> v;
		v.push_back(channel);
		return this->Subscribe(v);
	}

	bool Equipment::Unsubscribe(const std::string& channel)
	{
		std::vector<std::string> v;
		v.push_back(channel);
		return this->Unsubscribe(v);
	}

	json Equipment::GetJSON() const
	{
		json ret;

		ret["type"] = ConvertToString(this->equipmentType);
		ret["name"] = this->name;
		ret["manufacturer"] = this->manufacturer;
		ret["guid"] = this->guid;
		ret["purpose"] = this->purpose;

		if(this->hostname.size() > 0)
			ret["hostname"] = this->hostname;

		json jsParams = json::array();
		for (ParamSPtr pp : this->params)
			jsParams.push_back(pp->GetJSON());

		ret["params"] = jsParams;

		for (
			json::const_iterator it = this->clientData.begin();
			it != this->clientData.end();
			++it)
		{
			ret[it.key()] = it.value();
		}	

		return ret;
	}

	bool Equipment::TryTopicSend(
		const std::string& channel, 
		const std::string& payload)
	{
		{
			const std::lock_guard<std::mutex> lock(this->topicsMutex);
			if (this->topics.find(channel) == this->topics.end())
				return false;
		}
		//SimpleWeb::stream
		std::shared_ptr<WsServer::SendStream> strm =
			std::make_shared< WsServer::SendStream>();
		//
		*strm << payload;

		this->socket->send(strm);
		return true;
	}

	json Equipment::GetJSONSummary() const
	{
		json ret;

		ret["name"] = this->name;
		ret["guid"] = this->guid;

		return ret;
	}

	bool Equipment::SetSocket(WSConSPtr s)
	{
		if (this->socket.get() != nullptr)
			return false;

		this->socket = s;
		return true;
	}

	ParamSPtr Equipment::GetParam(const std::string& id)
	{
		for (ParamSPtr p : this->params)
		{
			if (p->GetID() == id)
				return p;
		}
		return nullptr;
	}

	
	json EquipmentList::GetJSON() const
	{
		json ret = json::array();

		for (auto it : this->itemsByGUID)
			ret.push_back(it.second->GetJSON());

		return ret;
	}

	json EquipmentList::GetJSONSummary() const
	{
		json ret = json::array();

		for (auto it : this->itemsByGUID)
			ret.push_back(it.second->GetJSONSummary());

		return ret;
	}

	bool EquipmentList::Register(WSConSPtr con, EquipmentSPtr eq)
	{
		// We only register if it's doesn't currently exist.
		//
		// It's assumed if eq isn't in itemsByGUID, con and eq won't be
		// in this->itemsBySocket.
		if (this->itemsByGUID.find(eq->GUID()) != this->itemsByGUID.end())
			return false;

		eq->SetSocket(con);

		this->itemsByGUID[eq->GUID()] = eq;
		this->itemsBySocket[con] = eq;

		return true;
	}

	bool EquipmentList::RemoveByGUID(const std::string& guid)
	{
		auto it = this->itemsByGUID.find(guid);
		if (it == this->itemsByGUID.end())
			return false;

		// Remove the GUID map

		// Get a copy before we invalidate the iterator by erasing it.
		EquipmentSPtr eq = it->second;
		this->itemsByGUID.erase(it);

		// And to keep them in sync, remove the socket map.
		// This is similar to the check in RemoveBySocket() which 
		// then deffers here. The overhead is ignored.
		auto itsock = this->itemsBySocket.find(eq->GetSocket());
		if (itsock != this->itemsBySocket.end())
			this->itemsBySocket.erase(itsock);

		eq->Deactivate();

		return true;
	}

	std::string EquipmentList::RemoveBySocket(WSConSPtr con)
	{
		auto it = this->itemsBySocket.find(con);
		if (it == this->itemsBySocket.end())
			return std::string();

		// Delegate to GUID, this means one less places syncing 
		// itemsBySocket and itemsBySocket take place.
		std::string ret = it->second->GUID();
		this->RemoveByGUID(it->second->GUID());
		return ret;
	}

	void EquipmentList::Broadcast(const std::string& message, std::set<WSConSPtr> ignore)
	{
		std::shared_ptr<WsServer::SendStream> sendStream = 
			std::make_shared< WsServer::SendStream>();

		*sendStream << message;

		for (auto it : this->itemsByGUID)
		{
			WSConSPtr con = it.second->GetSocket();
			if (ignore.find(con) != ignore.end())
				continue;

			con->send(sendStream);
		}
	}

	EquipmentSPtr EquipmentList::FindGUID(const std::string& guid)
	{
		auto it = this->itemsByGUID.find(guid);
		if (it == this->itemsByGUID.end())
			return nullptr;

		return it->second;
	}

	EquipmentSPtr EquipmentList::FindConnection(WSConSPtr con)
	{
		auto it = this->itemsBySocket.find(con);
		if (it == this->itemsBySocket.end())
			return nullptr;

		return it->second;
	}

	EquipmentListSPtr EquipmentList::Clone()
	{
		EquipmentList* pel = new EquipmentList();
		EquipmentListSPtr ret = EquipmentListSPtr(pel);

		pel->itemsByGUID.insert(
			this->itemsByGUID.begin(), 
			this->itemsByGUID.end());

		pel->itemsBySocket.insert(
			this->itemsBySocket.begin(),
			this->itemsBySocket.end());

		return ret;
	}
}