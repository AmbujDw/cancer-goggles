#include "SEquipment.h"

//https://stackoverflow.com/a/3248017/2680066
#include <boost/uuid/uuid.hpp>            // uuid class
#include <boost/uuid/uuid_generators.hpp> // generators
#include <boost/uuid/uuid_io.hpp>         // streaming operators etc.
#include <boost/lexical_cast.hpp>
#include <boost/chrono.hpp>
#include "ResponseUtils.h"

/// <summary>
/// GUID/UUID generator.
/// 
/// Used for GUID generation in Equipment. It's given its own class
/// in case the implementation is changed, in which case Generate()
/// should still be called but have a different implementation. This
/// allows extra utility functions to be added in the GUIGenerator
/// struct so it would be tied with the same scope as Generate().
/// </summary>
struct GUIDGenerator
{
	static std::string Generate()
	{
		boost::uuids::uuid uuid = boost::uuids::random_generator()();
		return boost::lexical_cast<std::string>(uuid);
	}
};

namespace CVG
{
	SEquipment::SEquipment(
		const std::string& name,
		const std::string& manufacturer,
		const std::string& purpose,
		const std::string& hostname,
		EQType type,
		std::vector<ParamSPtr> params,
		json clientData)
		: Equipment(
			name, 
			manufacturer,
			purpose,
			hostname,
			type,
			params,
			clientData)
	{
		// The GUID isn't specified, it's autogenerated on 
		// construction to ensure each Equipment instance
		// has a unique one.
		this->guid = GUIDGenerator::Generate();

		// https://stackoverflow.com/a/6012671/2680066
		// For now we're using boost chrono, the library that std::chrono 
		// was prototyped after, because it's a C++20 feature and the 
		// current agreed C++ used is C++14.
		const auto timeNow = std::chrono::system_clock::now();
		this->timestampRegistered = timeNow.time_since_epoch().count();
	}

	

	bool SEquipment::Deactivate()
	{
		if (this->active == false)
			return false;

		this->active = false;
		return true;
	}

	bool SEquipment::IsSubscribed(const std::string& channel)
	{
		const std::lock_guard<std::mutex> lock(this->topicsMutex);
		return this->topics.find(channel) != this->topics.end();
	}

	bool SEquipment::Subscribe(const std::vector<std::string>& newTopics)
	{
		bool ret = false;
		const std::lock_guard<std::mutex> lock(this->topicsMutex);
		for (const std::string& topic : newTopics)
		{
			if (this->topics.find(topic) != this->topics.end())
				continue;

			this->topics.insert(topic);
			ret = true;
		}
		return ret;
	}

	bool SEquipment::Unsubscribe(const std::vector<std::string>& remTopics)
	{
		bool ret = false;
		const std::lock_guard<std::mutex> lock(this->topicsMutex);
		for (const std::string& topic : remTopics)
		{
			if (this->topics.find(topic) == this->topics.end())
				continue;

			this->topics.erase(topic);
			ret = true;
		}
		return ret;
	}

	bool SEquipment::Subscribe(const std::string& channel)
	{
		std::vector<std::string> v;
		v.push_back(channel);
		return this->Subscribe(v);
	}

	bool SEquipment::Unsubscribe(const std::string& channel)
	{
		std::vector<std::string> v;
		v.push_back(channel);
		return this->Unsubscribe(v);
	}

	std::vector<std::string> SEquipment::Subscriptions()
	{
		const std::lock_guard<std::mutex> lock(this->topicsMutex);
		return std::vector<std::string>(this->topics.begin(), this->topics.end());
	}

	json SEquipment::GetJSON() const
	{
		json ret = this->Equipment::GetJSON();

		ret["regtime"] = this->timestampRegistered;

		return ret;
	}

	bool SEquipment::TryTopicSend(
		const std::string& channel, 
		const std::string& payload)
	{
		{
			const std::lock_guard<std::mutex> lock(this->topicsMutex);
			if (this->topics.find(channel) == this->topics.end())
				return false;
		}
		//SimpleWeb::stream
		std::shared_ptr<WsServer::OutMessage> strm =
			std::make_shared< WsServer::OutMessage>();
		//
		(*strm) << payload;

		this->socket->send(strm);
		return true;
	}

	json SEquipment::GetJSONSummary() const
	{
		return this->Equipment::GetJSONSummary();
	}

	bool SEquipment::SetSocket(WSConSPtr s)
	{
		if (this->socket.get() != nullptr)
			return false;

		this->socket = s;
		return true;
	}
}