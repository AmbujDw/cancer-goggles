#include "SEquipment.h"

//https://stackoverflow.com/a/3248017/2680066
#include <boost/uuid/uuid.hpp>            // uuid class
#include <boost/uuid/uuid_generators.hpp> // generators
#include <boost/uuid/uuid_io.hpp>         // streaming operators etc.
#include <boost/lexical_cast.hpp>
#include <boost/chrono.hpp>
#include "ResponseUtils.h"

/// <summary>
/// GUID/UUID generator.
/// 
/// Used for GUID generation in Equipment. It's given its own class
/// in case the implementation is changed, in which case Generate()
/// should still be called but have a different implementation. This
/// allows extra utility functions to be added in the GUIGenerator
/// struct so it would be tied with the same scope as Generate().
/// </summary>
struct GUIDGenerator
{
	static std::string Generate()
	{
		boost::uuids::uuid uuid = boost::uuids::random_generator()();
		return boost::lexical_cast<std::string>(uuid);
	}
};

namespace CVG
{
	// The GUID isn't specified, it's autogenerated on 
	// construction to ensure each Equipment instance
	// has a unique one.
	SEquipment::SEquipment(
		const std::string& name,
		const std::string& manufacturer,
		const std::string& purpose,
		const std::string& hostname,
		EQType type,
		std::vector<ParamSPtr> params,
		json clientData)
		: Equipment(
			name, 
			manufacturer,
			purpose,
			hostname,
			GUIDGenerator::Generate(),
			type,
			params,
			clientData)
	{
		// https://stackoverflow.com/a/6012671/2680066
		// For now we're using boost chrono, the library that std::chrono 
		// was prototyped after, because it's a C++20 feature and the 
		// current agreed C++ used is C++14.
		const auto timeNow = std::chrono::system_clock::now();
		this->timestampRegistered = timeNow.time_since_epoch().count();
	}

	

	bool SEquipment::Deactivate()
	{
		if (this->active == false)
			return false;

		this->active = false;
		return true;
	}

	bool SEquipment::IsSubscribed(const std::string& channel)
	{
		const std::lock_guard<std::mutex> lock(this->topicsMutex);
		return this->topics.find(channel) != this->topics.end();
	}

	bool SEquipment::Subscribe(const std::vector<std::string>& newTopics)
	{
		bool ret = false;
		const std::lock_guard<std::mutex> lock(this->topicsMutex);
		for (const std::string& topic : newTopics)
		{
			if (this->topics.find(topic) != this->topics.end())
				continue;

			this->topics.insert(topic);
			ret = true;
		}
		return ret;
	}

	bool SEquipment::Unsubscribe(const std::vector<std::string>& remTopics)
	{
		bool ret = false;
		const std::lock_guard<std::mutex> lock(this->topicsMutex);
		for (const std::string& topic : remTopics)
		{
			if (this->topics.find(topic) == this->topics.end())
				continue;

			this->topics.erase(topic);
			ret = true;
		}
		return ret;
	}

	bool SEquipment::Subscribe(const std::string& channel)
	{
		std::vector<std::string> v;
		v.push_back(channel);
		return this->Subscribe(v);
	}

	bool SEquipment::Unsubscribe(const std::string& channel)
	{
		std::vector<std::string> v;
		v.push_back(channel);
		return this->Unsubscribe(v);
	}

	std::vector<std::string> SEquipment::Subscriptions()
	{
		const std::lock_guard<std::mutex> lock(this->topicsMutex);
		return std::vector<std::string>(this->topics.begin(), this->topics.end());
	}

	json SEquipment::GetJSON() const
	{
		json ret = this->Equipment::GetJSON();

		ret["regtime"] = this->timestampRegistered;

		return ret;
	}

	bool SEquipment::TryTopicSend(
		const std::string& channel, 
		const std::string& payload)
	{
		{
			const std::lock_guard<std::mutex> lock(this->topicsMutex);
			if (this->topics.find(channel) == this->topics.end())
				return false;
		}
		//SimpleWeb::stream
		std::shared_ptr<WsServer::OutMessage> strm =
			std::make_shared< WsServer::OutMessage>();
		//
		(*strm) << payload;

		this->socket->send(strm);
		return true;
	}

	json SEquipment::GetJSONSummary() const
	{
		return this->Equipment::GetJSONSummary();
	}

	bool SEquipment::SetSocket(WSConSPtr s, const std::string& loopbackSub)
	{
		if (this->socket.get() != nullptr)
			return false;

		this->socket = s;

		// If no specified hostname, one is defaulted through
		// available into in WSConSPtr.
		std::string conHost = "";
		
		if(s->remote_endpoint().address().is_loopback())
			conHost = loopbackSub;
		else
			conHost = s->remote_endpoint().address().to_string();

		std::cout << "conEndpoint " << conHost << std::endl;

		// The endpoint address will often have extra formatting that 
		// we're better off without.
		// For example, an internal IPv4 address of 127.0.0.1 will come
		// back as ::ffff:127.0.0.1
		if(conHost.find("::ffff:", 0) == 0)
		{
			std::cout << "shortening to " << conHost << std::endl;
			conHost = conHost.substr(7);
		}

		// Include any other loopback addresses. If they're set to loopback,
		// it doesn't do any good to broadcast that out to other people to
		// reference (because it won't direct to the machine, just back to
		// itself).
		if(conHost == "127.0.0.1")
		{
			// Depending on the platform and libraries this was compiled on,
			// this may not give a useful name. But this is a sanity fallback
			// if loopbackSub fails - but it really shouldn't.
			conHost = boost::asio::ip::host_name();
		}

		if(this->hostname.empty())
			this->hostname = conHost;

		std::cout << "Setting hostname to " << this->hostname << std::endl;

		return true;
	}
}